----------------------------------------------------------------------------------
-- Company: Polytechnique Montreal
-- Author: Andy Gallay
-- Create Date: 06/17/2021 04:22:38 PM
-- Target Devices: Any
-- Tool Versions: 0.1
-- Description: DAC3484 Interface Module using FMC Header (Low-Pin Count) allowing 4 channels 16 bits-outputs
-- Revision 0.01
----------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.numeric_std.all;
library UNISIM;
use UNISIM.VComponents.all;

entity dac3484_interface_module is
    Port (
        -- Differential LVDS clock, should be either LVDS_25 or LVDS_18 depending on the used board.
        -- The clock drives every synchronous components of the design.
        clk_n : IN STD_LOGIC;
        clk_p : IN STD_LOGIC;
        
        -- Signals inputs. It is important to properly drives those signals when using the interface in a toplevel
        -- module : signal_1 and signal_3 should be DDR-driven by rising edge, while signal_2 and signal_4 should
        -- be DDR-driven by falling edge.
        -- If some signals are not used, user should provide "0000000000000000" input for every unused signal.
        signal_1 : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
        signal_2 : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
        signal_3 : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
        signal_4 : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
        
        -- Differential LVDS output. The output is DDR-driven so its value changes at both rising and falling edges.
        out_n : OUT STD_LOGIC_VECTOR(15 DOWNTO 0);
        out_p : OUT STD_LOGIC_VECTOR(15 DOWNTO 0);
        
        -- Differential LVDS clock. It is generated by clk_n/p input. DAC3484 uses it to synchronize latches for data input.
        dataclk_n : OUT STD_LOGIC;
        dataclk_p : OUT STD_LOGIC;
        
        -- Differential LVDS control signal. DAC3484 uses it to synchronize data processing. 
        sync_n: OUT STD_LOGIC;
        sync_p: OUT STD_LOGIC;
        
        -- Enable signals for synchronising inputs source and Interface Module. If signal_1/2/3/4 values depends on a clock signal,
        -- it should use signal_X_enable has a clock.
        signal_1_enable : OUT STD_LOGIC;
        signal_2_enable : OUT STD_LOGIC;
        signal_3_enable : OUT STD_LOGIC;
        signal_4_enable : OUT STD_LOGIC;
        
        -- CLK operating FPGA, for verification  purposes.
        single_clk_out : OUT STD_LOGIC
     );
end dac3484_interface_module;

architecture Behavioral of dac3484_interface_module is

signal single_clk : STD_LOGIC;
signal OUTPUT_BUFFER : STD_LOGIC_VECTOR(15 DOWNTO 0);

signal RISING_EDGE_BUFFER : STD_LOGIC_VECTOR(15 DOWNTO 0);
signal FALLING_EDGE_BUFFER : STD_LOGIC_VECTOR(15 DOWNTO 0);

signal rising_edge_switch : STD_LOGIC := '1';
signal falling_edge_switch : STD_LOGIC := '1';

begin

    -- IBUFDS to transform LVDS (differential) clock to single ended clock.
    -- LVDS clock is received as an input from external clock generator source.
    IBUFDS_clk : IBUFDS
    port map (
        O => single_clk,
        I => clk_p,
        IB => clk_n
    );
    
    -- OBUFDS to transform OUTPUT_BUFFER (single ended) to differential output.
    -- LVDS output is then processed by DAC3484.
    OBUFDS_GEN:
    for INDEX in 0 to 15 generate
        OBUFDS_INST : OBUFDS
        port map (
            O => out_p(INDEX),
            OB => out_n(INDEX),
            I => OUTPUT_BUFFER(INDEX)
        );
    end generate OBUFDS_GEN;
    
    -- OBUFDS to transform single_clk (single ended) to differential data_clk.
    -- LVDS dataclk is used by DAC3484 to latch-in data from the FPGA.
    OBUFDS_DATACLK: OBUFDS
    port map (
        O => dataclk_p,
        OB => dataclk_n,
        I => single_clk
    );
    
    -- OBUFDS to transform constant '1' signal (single ended) to differential sync (control signal).
    -- LVDS sync ensure that the DAC is synchronised for data transmission.
    OBUFDS_SYNC: OBUFDS
    port map (
        O => sync_p,
        OB => sync_n,
        I => '1'
    );
    
    -- ODDR buffer for double data rate transmission. D1 drives Q on rising edge while D2 drives Q on falling edge.
    ODDR_GEN:
    for INDEX in 0 to 15 generate
        ODDR_inst : ODDR
        generic map(
           DDR_CLK_EDGE => "OPPOSITE_EDGE", -- "OPPOSITE_EDGE" or "SAME_EDGE" 
           INIT => '0',   -- Initial value for Q port ('1' or '0')
           SRTYPE => "SYNC") -- Reset Type ("ASYNC" or "SYNC")
        port map (
           Q => OUTPUT_BUFFER(INDEX),   -- 1-bit DDR output
           C => single_clk,    -- 1-bit clock input
           CE => '1',  -- 1-bit clock enable input
           D1 => RISING_EDGE_BUFFER(INDEX),  -- 1-bit data input (positive edge)
           D2 => FALLING_EDGE_BUFFER(INDEX),  -- 1-bit data input (negative edge)
           R => '0'    -- 1-bit reset input
        );
    end generate;
    
    -- Uses rising edge for DDR data transfer. It switches between SIGNAL_1 and SIGNAL_3 on each rising edge.
    RISING_EDGE_PROCESS:
	process(single_clk)
	begin
	if single_clk'event and single_clk = '1' then
	   if rising_edge_switch = '1' then
	       RISING_EDGE_BUFFER <= signal_1;
	   else
	       RISING_EDGE_BUFFER <= signal_3;
	   end if;
	   rising_edge_switch <= not rising_edge_switch;
	end if;
	end process;
	
	-- Uses falling edge for DDR data transfer. It switches between SIGNAL_2 and SIGNAL_4 on each falling edge.
    FALLING_EDGE_PROCESS:
	process(single_clk)
	begin
	if single_clk'event and single_clk = '0' then
	   if falling_edge_switch = '1' then
	       FALLING_EDGE_BUFFER <= signal_2;
	   else
	       FALLING_EDGE_BUFFER <= signal_4;
	   end if;
	   falling_edge_switch <= not falling_edge_switch;
	end if;
	end process;
	
	-- Enable signals
	signal_1_enable <= rising_edge_switch;
	signal_2_enable <= falling_edge_switch;
	signal_3_enable <= not rising_edge_switch;
	signal_4_enable <= not falling_edge_switch;
	
	-- Single clock output
	single_clk_out <= single_clk;

end Behavioral;
